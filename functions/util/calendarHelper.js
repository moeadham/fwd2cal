/* eslint-disable max-len */
/* eslint-disable camelcase */
/* eslint-disable new-cap */
/* eslint-disable require-jsdoc */
const {logger} = require("firebase-functions");
const moment = require("moment-timezone");
const {google} = require("googleapis");
const handleAsync = require("./handleAsync");
const {getOauthClient} = require("./authHandler");
const ical = require("node-ical");
const _ = require("underscore");
const {sendEvent} = require("./analytics");

const DEFAULT_EVENT_LENGTH = 30;
const ONLY_INVITE_HOST = true;

function generateTimeObject(event, primaryCalendar) {
  // logger.log("event", event);
  const timezone = primaryCalendar.timeZone;
  let eventTimeZone = event.timeZone;
  logger.debug(`Calendar timezone: ${timezone}, eventTimezone: ${eventTimeZone}`);
  if (!Intl.DateTimeFormat(undefined, {timeZone: eventTimeZone})
      .resolvedOptions().timeZone) {
    console.error("Invalid Time Zone in event object:", eventTimeZone);
    // Fallback to primary calendar's timezone if event's timezone is invalid
    eventTimeZone = timezone;
  }
  const {date, start_time, end_time} = event;
  const startTime = `${date} ${start_time}`;
  const startDate = moment.tz(startTime, "DD MMMM YYYY HH:mm", eventTimeZone)
      .toDate();
  const endTime = `${date} ${end_time}`;
  let endDate;
  if (event.end_time) {
    try {
      endDate = moment.tz(endTime, "DD MMMM YYYY HH:mm", eventTimeZone).toDate();
      if (isNaN(endDate.getTime())) {
        throw new Error("Invalid end time");
      }
    } catch (error) {
      // Default 30 minutes to start_time
      endDate = new Date(startDate.getTime() + (DEFAULT_EVENT_LENGTH * 60000));
    }
  } else {
    // Default 30 minutes to start_time
    endDate = new Date(startDate.getTime() + (DEFAULT_EVENT_LENGTH * 60000));
  }
  const timeObject = {
    start: {
      dateTime: startDate.toISOString(),
      timeZone: eventTimeZone,
    },
    end: {
      dateTime: endDate.toISOString(),
      timeZone: eventTimeZone,
    },
  };
  return timeObject;
}

async function addEvent(oauth2Client, event, uid) {
  const calendar = google.calendar({version: "v3", auth: oauth2Client});
  const calendarList = await calendar.calendarList.list();
  const primaryCalendar = calendarList.data.items
      .find((calendar) => calendar.primary);
  if (!primaryCalendar) {
    throw new Error("Primary calendar not found");
  }
  const times = generateTimeObject(event, primaryCalendar);
  if (event.description === undefined || event.description === "undefined") {
    event.description = "";
  }
  event.description = `${event.description} 
\n\nThis event was generated by AI with fwd2cal.com.
\nDon't waste time creating events, just forward them to calendar@fwd2cal.com.`;
  const requestBody = {
    summary: event.summary,
    status: "confirmed",
    description: event.description,
    attendees: event.attendees.map((attendee) => ({email: attendee})),
    start: times.start,
    end: times.end,
  };
  if (event.location) {
    requestBody.location = event.location;
  }

  // This is needs a refactor.
  if (ONLY_INVITE_HOST) {
    requestBody.attendees = [
      {email: primaryCalendar.id,
        responseStatus: "accepted"}];
  }
  logger.log("Attempting to add event to google.");
  const insertEvent = await calendar.events.insert({
    calendarId: primaryCalendar.id,
    conferenceDataVersion: 1,
    resource: requestBody,
    sendNotifications: true,
    sendUpdates: "all",
  });
  logger.log("Event added to google.", insertEvent.data.htmlLink);
  sendEvent(uid, "addEvent", {result: "success"});
  insertEvent.data.calendarId = primaryCalendar.id;
  insertEvent.data.uid = uid;
  return insertEvent.data;
}

async function eventFromICS(icsFile) {
  const icsString = Buffer.from(icsFile.file).toString("utf-8");
  const ics = await ical.async.parseICS(icsString);
  const timezones = _.select(_.values(ics), (x) => {
    return x.type === "VTIMEZONE";
  });
  if (timezones.length > 1) {
    throw new Error("Multiple timezones found, too complicated.");
  }
  let timezone;
  if (timezones.length !== 0) {
    timezone = timezones[0].tzid;
  }
  const events = _.select(_.values(ics), (x) => {
    return x.type === "VEVENT";
  });
  if (events.length > 1) {
    throw new Error("Multiple events found, too complicated.");
  }
  const event = events[0];
  if (!event) {
    throw new Error("Event not found");
  }
  const start = moment(event.start).tz(timezone).format("HH:mm");
  const end = moment(event.end).tz(timezone).format("HH:mm");
  const date = moment(event.start).tz(timezone).format("DD MMMM YYYY");

  let summary;
  if (event.summary?.val) {
    summary = event.summary.val;
  } else {
    summary = event.summary;
  }

  let description;
  if (event.description?.val) {
    description = event.description.val;
  } else {
    description = event.description;
  }

  let location;
  if (event.location?.val) {
    location = event.location.val;
  } else {
    location = event.location;
  }

  const attendees = [];
  if (event.organizer?.val) {
    attendees.push(event.organizer.val.replace("MAILTO:", ""));
  }
  if (event.attendee && event.attendee.length > 0 && event.attendee[0].val) {
    attendees.push(...event.attendee.map((attendee) => attendee.val.replace("MAILTO:", "")));
  }

  const r = {
    summary: summary,
    location: location,
    description: description,
    conference_call: "",
    date: date,
    start_time: start,
    end_time: end,
    attendees: attendees,
  };
  if (timezone) {
    r.timezone = timezone;
  }
  return r;
}

async function getUserCalendars(oauth2Client, uid) {
  const calendar = google.calendar({version: "v3", auth: oauth2Client});
  const calendarList = await calendar.calendarList.list();
  // logger.log("CALENDAR OBJECT FULL:", calendarList);
  const calendars = calendarList.data.items.map((calendar) => ({
    kind: calendar.kind,
    etag: calendar.etag,
    selected: calendar.selected,
    accessRole: calendar.accessRole,
    conferenceProperties: calendar.conferenceProperties,
    calendar_id: calendar.id,
    summary: calendar.summary,
    summaryOverride: calendar.summaryOverride,
    description: calendar.description,
    primary: calendar.primary,
    timeZone: calendar.timeZone,
    location: calendar.location,
    hidden: calendar.hidden,
    deleted: calendar.deleted,
    uid: uid,
  }));
  // logger.log("Calendars:", calendars);
  return calendars;
}

async function inviteAdditionalAttendees(req, res) {
  let {uid, eventId, attendees, calendarId} = req.query;
  if (typeof attendees === "string") {
    try {
      attendees = JSON.parse(attendees);
    } catch (error) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(attendees)) {
        console.error("Attendees string is not a valid single email address:", attendees);
        return res.status(400).send({error: "Attendees string is not a valid single email address."});
      } else {
        attendees = [attendees];
      }
    }
  }
  // Can we authenticate with their calendar?
  const [oauthErr, oauth2Client] = await handleAsync(() => getOauthClient(uid));
  if (oauthErr) {
    logger.warn("Error getting oauth2Client", oauthErr);
    return res.redirect(302, "https://fwd2cal.com/404");
  }
  const calendar = google.calendar({version: "v3", auth: oauth2Client});
  const eventToUpdate = await calendar.events.get({
    calendarId: calendarId,
    eventId: eventId,
  });
  const htmlLink = eventToUpdate.data.htmlLink;
  attendees = attendees.map((attendee) => ({email: attendee}));
  eventToUpdate.data.attendees.push(...attendees);
  const updatedEvent = await calendar.events.update({
    calendarId: calendarId,
    eventId: eventId,
    sendNotifications: true,
    sendUpdates: "all",
    conferenceDataVersion: 1,
    requestBody: eventToUpdate.data,
  });
  logger.log(`Event updated with additional guests ${updatedEvent.data.id}`);
  return res.redirect(302, htmlLink);
}

module.exports = {
  addEvent,
  getUserCalendars,
  inviteAdditionalAttendees,
  eventFromICS,
};

